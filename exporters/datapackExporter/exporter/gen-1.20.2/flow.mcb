function entry {
	function set_frame {animation:'walk', frame:0, duration: 1}
}

function set_frame {
	$data modify storage animated_java:temp {} merge value {animation: $(animation), frame:$(frame)}
	$data modify storage animated_java:temp nodes set from animated_java:project_name animations.$(animation).nodes
	data modify storage animated_java:temp uuid_map set from entity @s uuid_map

	# For each uuid in nodes
	execute store result score #count aj.i if data storage animated_java:temp nodes[]
	{
		data modify storage animated_java:temp uuid merge from storage animated_java:temp nodes[-1]

		function map_node_uuid_to_entity_uuid with storage animated_java:temp
		scoreboard players set #success aj.i 0
		execute store success score #success aj.i if data storage animated_java:temp {type:'bone'} run function animated_java:set_bone_transformation with storage animated_java:temp
		execute if score #success aj.i matches 0 run function animated_java:set_locator_transformation with storage animated_java:temp

		data remove storage animated_java:temp nodes[-1]

		scoreboard players remove #count aj.i 1
		execute if score #count aj.i matches 1.. run function $block
	}
}

function set_frame_animation_specific {
	$data modify storage animated_java:temp {} merge value {animation: <%animation.name%>, frame:$(frame)}
	data modify storage animated_java:temp uuid_map set from entity @s uuid_map

	# AJ only includes nodes modified by this animation while generating this function
	LOOP(nodes, node) {
		data modify storage animated_java:temp uuidset from storage animated_java:project_name animations.<%animation.name%>.frames[$(frame)].nodes[{uuid: <%node.uuid%>}]
		function map_node_uuid_to_entity_uuid with storage animated_java:temp
		function animated_java:set_bone_transformation with storage animated_java:temp
	}
}

function set_bone_transformation {
	$data modify storage animated_java:project_name animations.$(animation).frames[$(frame)].nodes[$(uuid)].duration set value $(duration)
	$execute as $(uuid) run data modify entity @s {} merge from storage animated_java:project_name animations.$(animation).frames[$(frame)].nodes[$(uuid)]
}

function set_locator_transformation {
	$execute as $(uuid) run data modify entity @s {} merge from storage animated_java:project_name animations.$(animation).frames[$(frame)].nodes[$(uuid)]
}

function map_node_uuid_to_entity_uuid {
	$data modify storage animated_java:temp uuid set from storage animated_java:temp uuid_map[$(uuid)]
}

loot storage {
	"animated_java:project_name": {
		"animations": {
			"$(animation)": {
				"nodes": [
					{
						"type": "bone",
						"uuid": "$(uuid)",
					},
					{
						"type": "locator",
						"uuid": "$(uuid)",
					}
				],
				"frames": [
					{
						"nodes": {
							"$(bone_uuid)": {
								"transformation": {},
								"start_interpolation": 0,
								"duration": 1,
							},
							"$(locator_uuid)": {
								"Position": [],
								"Rotation": [],
							}
						}
					}
				]
			}
		}
	},
	"animated_java:temp": {
		"animation": "walk",
		"frame": 0,
		"nodes": [
			{
				"type": "bone",
				"uuid": "$(uuid)",
			},
			{
				"type": "locator",
				"uuid": "$(uuid)",
			}
		],
		"uuid_map": {
			"$(node_uuid)": "$(entity_uuid)"
		}
	}
}


###########################
#--- The new solution? ---#
###########################

loot aj:project_name_storage {
	"animations": {
		"$(animation)": {
			"frames": [
				{
					"nodes": {
						"$(bone_name)": {
							"transformation": {},
							"start_interpolation": 0,
							"duration": 1,
						},
						"$(locator_name)": {
							"x": 0,
							"y": 0,
							"z": 0,
							"rx": 0,
							"ry": 0,
						}
					}
				}
			]
		}
	},
}

loot root_entity_nbt {
	"data": {
		"nodes": {
			"$(bone_name)": {
				"name": "$(bone_name)",
				"uuid": "$(bone_entity_uuid)",
			},
			"$(locator_name)": {
				"name": "$(locator_name)",
				"uuid": "$(locator_entity_uuid)",
			}
		}
	}
}

function summon {
	# Summon all the entities
	summon minecraft:item_display ~ ~ ~ {...}
	# Init storage
	(
		data modify storage aj:temp data set value {
			nodes: {
				"bone1": {
					name: "bone1",
					uuid: ""
				},
				"bone2": {
					name: "bone2",
					uuid: ""
				},
				"locator1": {
					name: "locator1",
					uuid: ""
				},
			}
		}
	)
	# Then as each bone entity (selected via tags), store the correct UUID in the correct key.
	execute as @e[type=minecraft:item_display,tag=aj.root_entity,tag=new,limit=1,distance=..0.01] run {
		execute on passengers run {
			execute if entity @s[tag=bone1] run data modify storage aj:temp data.nodes.bone1.uuid set from entity @s uuid
			execute if entity @s[tag=bone2] run data modify storage aj:temp data.nodes.bone2.uuid set from entity @s uuid
			execute if entity @s[tag=locator1] run data modify storage aj:temp data.nodes.locator1.uuid set from entity @s uuid
		}
		data modify entity @s data set from storage aj:temp data
	}
}

function apply_frame {
	# Executed as root
	# Load animation data
	$data modify storage aj:temp animation set from storage aj:project_name animations.$(animation)
	# Load frame data
	execute store result data storage aj:temp frame int 1 run scoreboard players get @s aj.frame
	{
		$data modify storage aj:temp frame_data from storage aj:temp animation.frames[$(frame)]
		function apply_bone_frame_data with storage aj:temp data.nodes.bone1
		function apply_bone_frame_data with storage aj:temp data.nodes.bone2
		# Locators need special treatment since their position and rotation are applied via teleportation, and accessing sub-object data is not possible.
		data modify storage aj:temp data.nodes.locator1 merge from storage aj:temp frame_data.nodes.locator1
		function apply_locator_frame_data with storage aj:temp data.nodes.locator1
	} with storage aj:temp
}

function apply_bone_frame_data {
	$execute as $(uuid) run data modify entity @s {} merge from storage aj:temp frame_data.nodes.$(name).merge
}

function apply_locator_frame_data {
	$execute as $(uuid) run tp @s ~$(x) ~$(y) ~$(z) ~$(rx) ~$(ry)
}
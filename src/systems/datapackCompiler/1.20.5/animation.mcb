# TODO - Move all internal functions into an internal namespace, and only have user-facing functions in the main `animated_java:<%export_namespace%>` namespace.
import ../global.mcbt

function on_load {
	data modify storage <%project_storage%> rig_hash set value <%"'" + rig_hash + "'"%>

	IF (use_storage_for_animation) {
		REPEAT (animations) as animation {
			data remove storage <%project_storage%>/animations <%animation.storage_name%>
		}
		<%animationStorage.join('\n')%>
	}
	<%%
		animations.forEach(animation => {
			emit(`scoreboard objectives add ${OBJECTIVES.FRAME(animation.storage_name)} dummy`)
		})
	%%>
}

function remove_animation_objectives {
	<%%
		animations.forEach(animation => {
			emit(`scoreboard objectives remove ${OBJECTIVES.FRAME(animation.storage_name)}`)
		})
	%%>
	tellraw @a <%TELLRAW.UNINSTALL()%>
}

function invalid_version_warning {
	# This function will contain a tellraw if the datapack is loaded in the wrong version.
}

dir root {
	function on_tick {
		execute unless entity @s[tag=<%TAGS.PROJECT_ROOT(export_namespace)%>] run return 0

		# Custom pre-tick function
		IF (on_pre_tick_function) {
			<%%
				emit.mcb(on_pre_tick_function)
			%%>
		}

		# Once we have more than 8 animations, calling a function only if at least one animation is playing is more efficient.
		IF (animations.length > 8) {
			# If no animations are playing, we can skip all animation logic.
			# This helps reduce ticking commands for rigs that are idle.
			execute \
				unless entity @s[<%animations.map(anim => 'tag=!' + TAGS.ANIMATION_PLAYING(export_namespace, anim.storage_name)).join(',')%>] \
			run block tick_animations {
				REPEAT (animations) as animation {
					execute if entity @s[tag=<%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>] run \
						function *<%export_namespace%>/animations/<%animation.storage_name%>/zzz/on_tick
				}
			}
		} ELSE {
			REPEAT (animations) as animation {
				execute if entity @s[tag=<%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>] run \
					function *<%export_namespace%>/animations/<%animation.storage_name%>/zzz/on_tick
			}
		}

		IF (auto_update_rig_orientation) {
			IF (has_locators || has_cameras) {
				execute \
					on passengers \
					if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
				run function ./on_tick/transform_floating_entities
			}
			execute on passengers run tp @s ~ ~ ~ ~ ~
		} ELSE IF (has_ticking_locators) {
			execute \
				on passengers \
				if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
			run function ./on_tick/transform_locators
		}

		# Custom post-tick function
		IF (on_post_tick_function) {
			<%%
				emit.mcb(on_post_tick_function)
			%%>
		}
	}

	IF (has_locators || has_cameras) {
		dir on_tick {
			function transform_locators {
				REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator')) as locator {
					block select_locator_<%locator.storage_name%> { with entity @s data.locators.<%locator.storage_name%>
						IF (locator.config?.use_entity) {
							$execute \
								as $(uuid) \
								positioned ^$(px) ^$(py) ^$(pz) \
								rotated ~$(ry) ~$(rx) \
							run block as_locator_<%locator.storage_name%> {
								tp @s ~ ~ ~ ~ ~

								IF (locator.config?.sync_passenger_rotation) {
									execute on passengers run tp @s ~ ~ ~ ~ ~
								}

								IF (locator.config?.on_tick_function) {
									<%%
										emit.mcb(locator.config.on_tick_function)
									%%>
								}
							}
						} ELSE IF (locator.config?.on_tick_function) {
							$execute \
								positioned ^$(px) ^$(py) ^$(pz) \
								rotated ~$(ry) ~$(rx) \
							run block at_locator_<%locator.storage_name%> {
								<%%
									emit.mcb(locator.config.on_tick_function)
								%%>
							}
						}
					}
				}
			}

			function transform_floating_entities {
				function ./transform_locators

				REPEAT (Object.values(rig.nodes).filter(node => node.type === 'camera')) as camera {
					block select_camera_<%camera.storage_name%> { with entity @s data.cameras.<%camera.storage_name%>
						$execute \
							as $(uuid) \
							positioned ^$(px) ^$(py) ^$(pz) \
							rotated ~$(ry) ~$(rx) \
						run tp @s ~ ~ ~ ~ ~
					}
				}
			}
		}
	}
}

IF (!auto_update_rig_orientation) {
	function move {
		debug assert executed_as_root_entity

		tp @s ~ ~ ~ ~ ~

		IF (has_locators || has_cameras) {
			execute \
				at @s on passengers \
				if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
			run function ./on_tick/transform_floating_entities
		}
		execute at @s on passengers run tp @s ~ ~ ~ ~ ~
	}
} ELSE {
	function move {
		tellraw @a <%TELLRAW.AUTO_UPDATE_RIG_ORIENTATION_MOVE_WARNING()%>
	}
}

dir animations {
	REPEAT (animations) as animation {
		dir <%animation.storage_name%> {
			function play {
				debug assert executed_as_root_entity

				function *<%export_namespace%>/animations/pause_all

				tag @s add <%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>
				scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> 0
				tag @s add <%TAGS.TRANSFORMS_ONLY()%>
				execute at @s run function ./zzz/set_frame {frame: 0}
				tag @s remove <%TAGS.TRANSFORMS_ONLY()%>
			}

			function stop {
				debug assert executed_as_root_entity

				function *<%export_namespace%>/animations/pause_all

				scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> 0
				tag @s add <%TAGS.TRANSFORMS_ONLY()%>
				execute at @s run function ./zzz/set_frame {frame: 0}
				tag @s remove <%TAGS.TRANSFORMS_ONLY()%>
			}

			function pause {
				debug assert executed_as_root_entity

				tag @s remove <%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>
			}

			function resume {
				debug assert executed_as_root_entity

				tag @s add <%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>
			}

			function next_frame {
				debug assert executed_as_root_entity

				execute if score @s <%OBJECTIVES.FRAME(animation.storage_name)%> matches <%animation.duration%>.. run scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> 1
				data remove storage <%temp_storage%> args
				execute store result storage <%temp_storage%> args.frame int 1 run scoreboard players get @s <%OBJECTIVES.FRAME(animation.storage_name)%>
				execute at @s run function ./zzz/apply_frame with storage <%temp_storage%> args
				scoreboard players add @s <%OBJECTIVES.FRAME(animation.storage_name)%> 1
			}

			function set_frame {
				# Sets the frame without interpolation
				#ARGS: {frame: int}
				debug assert executed_as_root_entity

				data remove storage <%temp_storage%> args
				$execute store result storage <%temp_storage%> args.frame int 1 run scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> $(frame)
				execute at @s run function ./zzz/set_frame with storage <%temp_storage%> args
			}

			function apply_frame {
				#ARGS: {frame: int}
				debug assert executed_as_root_entity

				data remove storage <%temp_storage%> args
				$execute store result storage <%temp_storage%> args.frame int 1 run scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> $(frame)
				execute at @s run function ./zzz/apply_frame with storage <%temp_storage%> args
			}

			function tween {
				# Attempts to smoothly transition from the currently playing animation into this one.
				#ARGS: {duration: int, to_frame: int}
				debug assert executed_as_root_entity

				function *<%export_namespace%>/animations/pause_all

				tag @s add <%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>
				$scoreboard players set @s <%OBJECTIVES.TWEEN_DURATION()%> $(duration)
				$scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> $(to_frame)

				scoreboard players operation #this <%OBJECTIVES.I()%> = @s <%OBJECTIVES.TWEEN_DURATION()%>
				tag @s add <%TAGS.TRANSFORMS_ONLY()%>
				execute at @s run function ./zzz/apply_frame {frame: 0}
				$execute at @s run function ./zzz/apply_frame {frame: $(to_frame)}
				tag @s remove <%TAGS.TRANSFORMS_ONLY()%>
				execute on passengers store result entity @s interpolation_duration int 1 run scoreboard players get #this <%OBJECTIVES.I()%>
			}

			dir zzz {
				function on_tick {
					# Tweening logic
					scoreboard players remove @s <%OBJECTIVES.TWEEN_DURATION()%> 1
					execute if score @s <%OBJECTIVES.TWEEN_DURATION()%> matches 1.. run return 1
					execute if score @s <%OBJECTIVES.TWEEN_DURATION()%> matches 0 on passengers run \
						data modify entity @s interpolation_duration set value <%interpolation_duration%>
					# Animation logic
					IF (animation.loop_mode === 'loop' && animation.loop_delay === 0) {
						# Makes sure function keyframes in the last frame of the animation are activated.
						execute if score @s <%OBJECTIVES.FRAME(animation.storage_name)%> matches -1 run \
							block function_keyframe_loop_patch {
								function ./apply_frame {frame: <%animation.duration-1%>}
								scoreboard players add @s <%OBJECTIVES.FRAME(animation.storage_name)%> 1
							}
					}
					data remove storage <%temp_storage%> args
					execute store result storage <%temp_storage%> args.frame int 1 run \
						scoreboard players get @s <%OBJECTIVES.FRAME(animation.storage_name)%>
					function ./apply_frame with storage <%temp_storage%> args
					IF (animation.loop_mode === 'loop') {
						# Loop the animation back to the start once it reaches the last frame.
						# If loop_delay is 0, the animation will loop instantly, otherwise, it will wait for the specified amount of ticks.
						execute \
							if score @s <%OBJECTIVES.FRAME(animation.storage_name)%> \
							matches <%animation.duration-2 + animation.loop_delay%>.. \
						run return run \
							scoreboard players set @s <%OBJECTIVES.FRAME(animation.storage_name)%> <%animation.loop_delay === 0 ? -1 : 0%>
					} ELSE IF (animation.loop_mode === 'hold') {
						# Pause the animation at the last frame.
						execute \
							if score @s <%OBJECTIVES.FRAME(animation.storage_name)%> \
							matches <%animation.duration-1%>.. \
						run return run \
							function ../pause
					} ELSE IF (animation.loop_mode === 'once') {
						# Stop the animation once it reaches the last frame.
						execute \
							if score @s <%OBJECTIVES.FRAME(animation.storage_name)%> \
							matches <%animation.duration-1%> \
						run return run \
							function ../stop
					}
					scoreboard players add @s <%OBJECTIVES.FRAME(animation.storage_name)%> 1
				}

				IF (use_storage_for_animation) {
					function set_frame {
						#ARGS: {frame: int}
						$function ./apply_frame {frame: $(frame)}
						execute on passengers run data modify entity @s[tag=!<%TAGS.GLOBAL_DATA()%>] start_interpolation set value -1
						return 1
					}

					function apply_frame {
						#ARGS: {frame: int}
						REPEAT (Object.values(animation.modified_nodes).sort(nodeSorter)) as node {
							IF (BONE_TYPES.includes(node.type)) {
								$execute on passengers if entity @s[tag=<%TAGS.PROJECT_NODE_NAMED(export_namespace, node.storage_name)%>] run \
									data modify entity @s {} merge from \
										storage <%project_storage%>/animations <%animation.storage_name%>.$(frame).<%node.type.charAt(0) + '_' + node.storage_name%>
							} ELSE IF (node.type === 'locator' || node.type === 'camera') {
								$execute on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run \
									$data modify entity @s data.uuids_by_name.<%node.type + '_' + node.storage_name%> merge from \
										storage <%project_storage%>/animations <%animation.storage_name%>.$(frame).<%node.type.charAt(0) + '_' + node.storage_name%>
							}
						}

						IF (animation.frames.some(anim => anim.variant)) {
							$execute \
								if data storage <%project_storage%>/animations <%animation.storage_name%>.$(frame).variant \
								unless entity @s[tag=<%TAGS.TRANSFORMS_ONLY()%>] \
							run { with storage <%project_storage%>/animations <%animation.storage_name%>.$(frame).variant
								#ARGS: {name: string, condition: string}
								$execute $(condition)run function *<%export_namespace%>/variants/$(name)/apply
							}
						}

						return 1
					}
				} ELSE {
					function set_frame {
						# Sets the frame without interpolation
						#ARGS: {frame: int}
						$execute on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run \
							function ./frames/$(frame) with entity @s data.uuids_by_name

						execute on passengers if entity @s[tag=!<%TAGS.GLOBAL_DATA()%>] run \
							data modify entity @s start_interpolation set value -1

						return 1
					}

					function apply_frame {
						#ARGS: {frame: int}
						$execute on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run \
							function ./frames/$(frame) with entity @s data.uuids_by_name

						return 1
					}

					# FIXME - %NEWLINE_PATCH% is a temporary solution to temporarily fix an MCB bug where extra newlines are being added to the output.
					dir frames {
						<%%
							// A record of node uuid to INodeTransform.
							// Keeps track of the last time a bone was updated.
							// Only used for step keyframe interpolation.
							let hasFunction = false
							const lastActiveFrame = {}
							const modifiedNodes = Object.values(animation.modified_nodes).filter(n => n.type !== 'struct').sort(nodeSorter);
							for (const [frameIndex, frame] of animation.frames.entries()) {
								const to_merge = {cameras: {}, locators: {}}
								let frameFunc = ``;
								for (const node of modifiedNodes) {
									const transform = frame.node_transforms[node.uuid]
									// Skip if the node doesn't have a transform for this frame.
									if (!transform) continue
									switch (node.type) {
										case 'bone':
										case 'text_display':
										case 'item_display':
										case 'block_display': {
											const lastFrame = lastActiveFrame[node.uuid]
											const isStepInterpolation = !!(lastFrame?.interpolation === 'step')
											lastActiveFrame[node.uuid] = transform

											if (transform.interpolation === 'pre-post' || isStepInterpolation) {
												frameFunc +=
													`\n$data merge entity $(${node.type + '_' + node.storage_name})%NEWLINE_PATCH%{`
														+ `transformation: ${matrixToNbtFloatArray(transform.matrix).toString()},`
														+ `start_interpolation: ${isStepInterpolation ? -1 : 0},`
														+ `interpolation_duration: ${isStepInterpolation ? 0 : interpolation_duration}`
													+ `}`
											} else {
												frameFunc +=
													`\n$data merge entity $(${node.type + '_' + node.storage_name})%NEWLINE_PATCH%{`
														+ `transformation: ${matrixToNbtFloatArray(transform.matrix).toString()},`
														+ `start_interpolation: 0,`
														+ `interpolation_duration: ${interpolation_duration}`
													+ `}`
											}
											;hasFunction = true
											break
										}
										case 'locator': {
											const lastFrame = lastActiveFrame[node.uuid]
											lastActiveFrame[node.uuid] = transform
											;if (!lastFrame || matrixToNbtFloatArray(transform.matrix).toString() !== matrixToNbtFloatArray(lastFrame.matrix).toString()) {
												to_merge.locators[node.storage_name] = {
													px: transform.pos[0],
													py: transform.pos[1],
													pz: transform.pos[2],
													ry: transform.head_rot[1],
													rx: transform.head_rot[0]
												};
											}

											if (transform.function) {
												if (node.config?.use_entity) {
													frameFunc +=
														`\n$execute on vehicle unless entity @s[tag=${TAGS.TRANSFORMS_ONLY()}] as $(${node.type + '_' + node.storage_name}) `
														+ `positioned ^${roundTo(transform.pos[0], 10)} ^${roundTo(transform.pos[1], 10)} ^${roundTo(transform.pos[2], 10)} `
														+ `rotated ~${roundTo(transform.head_rot[1], 10)} ~${roundTo(transform.head_rot[0], 10)} `
														+ `${transform.function_execute_condition ? transform.function_execute_condition + ' ' : ''}run `
														+ `block ${frameIndex}_locator_${node.storage_name}%NEWLINE_PATCH%{\n`
															+ `tp @s ~ ~ ~ ~ ~\n`
															+ `${transform.function}`
														+ `\n}`
												} else {
													frameFunc +=
														`\nexecute on vehicle unless entity @s[tag=${TAGS.TRANSFORMS_ONLY()}] `
														+ `positioned ^${roundTo(transform.pos[0], 10)} ^${roundTo(transform.pos[1], 10)} ^${roundTo(transform.pos[2], 10)} `
														+ `rotated ~${roundTo(transform.head_rot[1], 10)} ~${roundTo(transform.head_rot[0], 10)} `
														+ `${transform.function_execute_condition ? transform.function_execute_condition + ' ' : ''}run `
														+ `block ${frameIndex}_locator_${node.storage_name}%NEWLINE_PATCH%{\n`
															+ `${transform.function}`
														+ `\n}`
												}
											}
											break
										}
										case 'camera': {
											const lastFrame = lastActiveFrame[node.uuid]
											lastActiveFrame[node.uuid] = transform
											;if (!lastFrame || matrixToNbtFloatArray(transform.matrix).toString() !== matrixToNbtFloatArray(lastFrame.matrix).toString()) {
												to_merge.cameras[node.storage_name] = {
													px: transform.pos[0],
													py: transform.pos[1],
													pz: transform.pos[2],
													ry: transform.head_rot[1],
													rx: transform.head_rot[0]
												};
											}
											;break
										}
									}
								}

								if (Object.keys(to_merge.locators).length > 0 || Object.keys(to_merge.cameras).length > 0) {
									frameFunc += `\ndata modify entity @s data merge value ${JSON.stringify(to_merge)}`
									if (!auto_update_rig_orientation) {
										frameFunc += `\nfunction ./on_tick/transform_floating_entities`
									}
									hasFunction = true
								}

								if (frame.variants?.length) {
									const variant = rig.variants[frame.variants[0]]
									if (!variant) {
										throw new Error(`Could not find Variant with uuid "${frame.variants[0]}" while generating frame "${frameIndex}" of animation "${animation.name}".`)
									}
									const execute_condition = frame.variants_execute_condition ? frame.variants_execute_condition + ' ' : ''
									frameFunc += `\nexecute on vehicle unless entity @s[tag=${TAGS.TRANSFORMS_ONLY()}] ${execute_condition}run function *${export_namespace}/variants/${variant.name}/apply`
									;hasFunction = true
								}

								// Root function keyframes.
								if (frame.function) {
									const execute_condition = frame.function_execute_condition ? frame.function_execute_condition + ' ' : ''
									frameFunc += `\nexecute on vehicle unless entity @s[tag=${TAGS.TRANSFORMS_ONLY()}] at @s ${execute_condition}run block ${frameIndex}_root_function%NEWLINE_PATCH%{\n${frame.function}\n}`
									;hasFunction = true
								}
								;if (frameFunc.length > 0) {
									frameFunc = `function ${frameIndex}%NEWLINE_PATCH%{${frameFunc}\n}`
									emit.mcb(frameFunc.replaceAll(/%NEWLINE_PATCH%\n?/g, ' '))
								}
							}
						%%>
					}
				}
			}
		}
	}
	function pause_all {
		# Pauses all animations
		debug assert executed_as_root_entity

		REPEAT (animations) as animation {
			tag @s remove <%TAGS.ANIMATION_PLAYING(export_namespace, animation.storage_name)%>
		}
	}
}

function summon {
	#Args: {args:{variant: string, animation: string, frame: int, start_animation: boolean}}
	# frame is ignored unless animation is specified.

	data modify storage <%temp_storage%> args set value {variant:'', animation:'', frame: 0}
	$execute store success score #success <%OBJECTIVES.I()%> run data modify storage <%temp_storage%> args set value $(args)

	summon minecraft:item_display ~ ~ ~ { \
		Tags:[ \
			'<%TAGS.NEW()%>', \
			'<%TAGS.GLOBAL_ENTITY()%>', \
			'<%TAGS.GLOBAL_ROOT()%>', \
			'<%TAGS.PROJECT_ENTITY(export_namespace)%>', \
			'<%TAGS.PROJECT_ROOT(export_namespace)%>' \
		], \
		teleport_duration: 0, \
		interpolation_duration: <%interpolation_duration%>, \
		Passengers:<%root_entity_passengers%>, \
	}
	execute as @e[ \
		type=minecraft:item_display, \
		tag=<%TAGS.PROJECT_ROOT(export_namespace)%>, \
		tag=<%TAGS.NEW()%>, \
		limit=1, distance=..0.01 \
	] run block zzz/summon/as_root_entity {
		execute store result score @s <%OBJECTIVES.ID()%> run scoreboard players add aj.last_id <%OBJECTIVES.ID()%> 1
		# Align the position and rotation of the root with the command context.
		tp @s ~ ~ ~ ~ ~

		function *global/gu/get_entity_uuid_string
		execute at @s on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run block as_data_entity {
			# Rig Root UUID
			data modify entity @s data.uuids append from storage <%gu_storage%> out
			# Data Entity UUID
			function *global/gu/get_entity_uuid_string
			data modify entity @s data.uuids append from storage <%gu_storage%> out
			data modify entity @s data.uuids_by_name.data_data set from storage <%gu_storage%> out

			REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator' && node.config?.use_entity)) as locator {
				summon <%locator.config.entity_type%> \
					^<%roundTo(locator.default_transform.pos[0], 10)%> \
					^<%roundTo(locator.default_transform.pos[1], 10)%> \
					^<%roundTo(locator.default_transform.pos[2], 10)%> \
					{Tags:<%getNodeTags(locator, rig)%>}
				execute \
					as @e[ \
						type=<%locator.config.entity_type%>, \
						tag=<%TAGS.PROJECT_LOCATOR_NAMED(export_namespace, locator.storage_name)%>, \
						tag=<%TAGS.NEW()%>, \
						limit=1, distance=..<%Math.ceil(locator.max_distance)%> \
					] \
				run block as_locator/<%locator.storage_name%> {
				# run block ../as_locator/<%locator.storage_name%> {
					tag @s remove <%TAGS.NEW()%>
					function *global/gu/get_entity_uuid_string
				}
				data modify entity @s data.uuids append from storage <%gu_storage%> out
				data modify entity @s data.uuids_by_name.<%locator.type + '_' + locator.storage_name%> set from storage <%gu_storage%> out
				data modify entity @s data.locators.<%locator.storage_name%>.uuid set from storage <%gu_storage%> out
			}

			REPEAT (Object.values(rig.nodes).filter(node => node.type === 'camera')) as camera {
				summon minecraft:item_display \
					^<%roundTo(camera.default_transform.pos[0], 10)%> \
					^<%roundTo(camera.default_transform.pos[1], 10)%> \
					^<%roundTo(camera.default_transform.pos[2], 10)%> \
					{Tags:<%getNodeTags(camera, rig)%>, teleport_duration: 2}
				execute \
					as @e[ \
						type=minecraft:item_display, \
						tag=<%TAGS.PROJECT_CAMERA_NAMED(export_namespace, camera.storage_name)%>, \
						tag=<%TAGS.NEW()%>, \
						limit=1, distance=..<%Math.ceil(camera.max_distance)%> \
					] \
				run block as_camera/<%camera.storage_name%> {
				# run block ../as_camera/<%camera.storage_name%> {
					tag @s remove <%TAGS.NEW()%>
					function *global/gu/get_entity_uuid_string
				}
				data modify entity @s data.uuids append from storage <%gu_storage%> out
				data modify entity @s data.uuids_by_name.<%camera.type + '_' + camera.storage_name%> set from storage <%gu_storage%> out
				data modify entity @s data.cameras.<%camera.storage_name%>.uuid set from storage <%gu_storage%> out
			}

			REPEAT (Object.values(rig.nodes).filter(node => BONE_TYPES.includes(node.type))) as node {
				execute \
					on vehicle \
					on passengers \
					if entity @s[tag=<%TAGS.PROJECT_NODE_NAMED(export_namespace, node.storage_name)%>] \
				run \
					function *global/gu/get_entity_uuid_string

				data modify entity @s data.uuids append from storage <%gu_storage%> out
				data modify entity @s data.uuids_by_name.<%node.type + '_' + node.storage_name%> set from storage <%gu_storage%> out
			}
		}

		# Variant Arguement
		IF (Object.keys(rig.variants).length > 1) {
			execute if data storage <%temp_storage%> args.variant run block variant_arg/process { with storage <%temp_storage%> args
				scoreboard players set #success <%OBJECTIVES.I()%> 0
				# If the variant argument is *explicitly* set to an empty string, return an error.
				execute if data storage <%temp_storage%> {args:{variant:''}} run return run block if_empty {
					# Tell the user that the variant cannot be empty.
					tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('variant')%>
					function *<%export_namespace%>/remove/this/without_on_remove_function
				}
				# Attempt to apply the requested variant.
				# We get the success of the `try_apply` function in just in case the user's arguments are *very* wrong.
				execute store success score #success <%OBJECTIVES.I()%> run block try_apply { with storage <%temp_storage%> args
					$execute if function animated_java:<%export_namespace%>/variants/$(variant)/apply run return 1
					# If the apply function fails, the variant doesn't exist, so we return an error.
					return fail
				}
				# If the apply function failed, return an error.
				execute unless score #success <%OBJECTIVES.I()%> matches 1 run return run block invalid_variant {
					# Tell the user that the provided variant doesn't exist, remove the rig, and list all available variants for this rig.
					tellraw @a <%TELLRAW.INVALID_VARIANT(rig.variants)%>
					function *<%export_namespace%>/remove/this/without_on_remove_function
				}
				scoreboard players set #success <%OBJECTIVES.I()%> 1
			}
		} ELSE {
			execute if data storage <%temp_storage%> args.variant run block zzz/variant_arg/no_variants_warning {
				tellraw @a <%TELLRAW.NO_VARIANTS()%>
				function *<%export_namespace%>/remove/this/without_on_remove_function
				scoreboard players set #success <%OBJECTIVES.I()%> 0
			}
		}
		execute if score #success <%OBJECTIVES.I()%> matches 0 run return fail

		function *<%export_namespace%>/set_default_pose

		# Animation Argument
		# If the animation argument is provided, attempt to apply the animation.
		execute if data storage <%temp_storage%> args.animation run block animation_arg/process { with storage <%temp_storage%> args
			scoreboard players set #success <%OBJECTIVES.I()%> 0
			# If the animation argument is *explicitly* set to an empty string, return an error.
			execute if data storage <%temp_storage%> {args:{animation:''}} run return run block if_empty {
				tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('animation')%>
				function *<%export_namespace%>/remove/this/without_on_remove_function
			}
			# Automatically set the frame argument to 0 if the frame argument is not provided.
			# Takes advantage of `store result score` setting the score to 0 if the command fails.
			execute \
				store result storage <%temp_storage%> args.frame int 1 \
				store result score #frame <%OBJECTIVES.I()%> \
			run \
				data get storage <%temp_storage%> args.frame
			# If the frame argument is negative, return an error.
			execute if score #frame <%OBJECTIVES.I()%> matches ..-1 run return run block no_negative {
				# Tell the user that the frame argument cannot be negative.
				tellraw @a <%TELLRAW.FRAME_CANNOT_BE_NEGATIVE()%>
				function *<%export_namespace%>/remove/this/without_on_remove_function
			}
			# Attempt to apply the animation frame.
			execute store success score #success <%OBJECTIVES.I()%> run block try_set_frame { with storage <%temp_storage%> args
				# Make sure we're only applying transforms when setting the summon pose.
				tag @s add <%TAGS.TRANSFORMS_ONLY()%>
				$execute store success score #success <%OBJECTIVES.I()%> run function *<%export_namespace%>/animations/$(animation)/zzz/set_frame with storage <%temp_storage%> args
				tag @s remove <%TAGS.TRANSFORMS_ONLY()%>
				execute if score #success <%OBJECTIVES.I()%> matches 1 run return 1
				# If the set_frame function fails, the animation doesn't exist, so we return an error.
				return fail
			}
			# If the set_frame function failed, return an error.
			execute unless score #success <%OBJECTIVES.I()%> matches 1 run return run block invalid_animation {
				# Tell the user that the provided animation doesn't exist, remove the rig, and list all available animations for this rig.
				tellraw @a <%TELLRAW.INVALID_ANIMATION(animations)%>
				function *<%export_namespace%>/remove/this/without_on_remove_function
			}

			# If the animation is successfully applied, and the start_animation argument is set to true, start the animation.
			execute if data storage <%temp_storage%> {args:{start_animation: true}} run block start_animation { with storage <%temp_storage%> args
				$function *<%export_namespace%>/animations/$(animation)/resume
			}
			scoreboard players set #success <%OBJECTIVES.I()%> 1
		}
		execute if score #success <%OBJECTIVES.I()%> matches 0 run return fail

		IF (has_locators || has_cameras) {
			execute \
				on passengers \
				if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
			run function ./on_tick/transform_floating_entities
		}
		execute on passengers run tp @s ~ ~ ~ ~ ~

		# Apply teleport duration
		data modify entity @s teleport_duration set value <%teleportation_duration%>
		execute on passengers run data modify entity @s teleport_duration set value <%teleportation_duration%>

		IF (has_entity_locators) {
			execute at @s on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run block locators_on_summon {
				REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator' && node.config?.use_entity && node.config.on_summon_function)) as locator {
					block { with entity @s data.locators.<%locator.storage_name%>
						$execute as $(uuid) at @s run block <%locator.storage_name%> {
							<%%
								emit.mcb(locator.config.on_summon_function)
							%%>
							# Track any custom entities on the locator.
							function *global/util/get_entity_stack_uuids
						}
					}
					data modify entity @s data.uuids append from storage <%temp_storage%> uuids
				}
			}
		}

		REPEAT (Object.values(rig.nodes).filter(node => BONE_TYPES.includes(node.type) && node.on_summon_function?.trim())) as node {
			execute \
				on passengers if entity @s[tag=<%TAGS.PROJECT_NODE_NAMED(export_namespace, node.storage_name)%>] \
			run block node_on_summon_<%node.storage_name%> {
				<%%
					emit.mcb(node.on_summon_function.trim())
				%%>
			}
		}

		IF (on_summon_function) {
			execute at @s run block rig_on_summon {
				<%%
					emit.mcb(on_summon_function)
				%%>
			}
		}

		# Remove the NEW tag from the root entity, and it's passengers.
		tag @s remove <%TAGS.NEW()%>
		execute on passengers run tag @s remove <%TAGS.NEW()%>
	}
}

IF (has_entity_locators) {
	function as_locator {
		#ARGS: {name: string, command: string}
		debug assert executed_as_root_entity

		data remove storage <%temp_storage%> args
		$data modify storage <%temp_storage%> args merge value {name:'$(name)', command:'$(command)', uuid:'+MISSING_UUID+'}

		IF (debug_mode) {
			execute if data storage <%temp_storage%> {args:{name:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('name')%>
			execute if data storage <%temp_storage%> {args:{command:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('command')%>
		}

		execute \
			on passengers \
			if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
		run block zzz/as_locator/as_data { with storage <%temp_storage%> args
			$data modify storage <%temp_storage%> args.uuid set from entity @s data.locators.$(name).uuid
			IF (debug_mode) {
				scoreboard players set #aj.check <%OBJECTIVES.I()%> 0
			}
			block execute_as_uuid { with storage <%temp_storage%> args
				IF (debug_mode) {
					# If the function successfully instantiated, the provided command is valid.
					scoreboard players set #aj.check <%OBJECTIVES.I()%> 1
				}
				$execute as $(uuid) at @s run return run $(command)
				IF (debug_mode) {
					# If the entity with the provided UUID doesn't exist, the locator wasn't found.
					tellraw @a <%TELLRAW.LOCATOR_ENTITY_NOT_FOUND()%>
				}
			}
			IF (debug_mode) {
				execute if score #aj.check <%OBJECTIVES.I()%> matches 0 run tellraw @a <%TELLRAW.LOCATOR_COMMAND_FAILED_TO_EXECUTE()%>
			}
		}
	}

	function as_all_locators {
		#ARGS: {command: string}
		debug assert executed_as_root_entity

		data remove storage <%temp_storage%> args
		$data modify storage <%temp_storage%> args merge value {command:'$(command)'}

		IF (debug_mode) {
			execute if data storage <%temp_storage%> {args:{command:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('command')%>
		}

		execute on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run block zzz/as_all_locators/as_data {
			REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator' && node.config?.use_entity)) as locator {
				data modify storage <%temp_storage%> args.uuid set from entity @s data.locators.<%locator.storage_name%>.uuid
				block execute_as_uuid { with storage <%temp_storage%> args
					$execute as $(uuid) at @s run $(command)
				}
			}
		}
	}
}

IF (has_locators) {
	function at_locator {
		#ARGS: {name: string, command: string}
		debug assert executed_as_root_entity

		data remove storage <%temp_storage%> args
		$data modify storage <%temp_storage%> args merge value {name:'$(name)', command:'$(command)'}

		IF (debug_mode) {
			execute if data storage <%temp_storage%> {args:{name:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('name')%>
			execute if data storage <%temp_storage%> {args:{command:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('command')%>
		}

		execute \
			at @s \
			on passengers \
			if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
		run block zzz/at_locator/as_data { with storage <%temp_storage%> args
			$data modify storage <%temp_storage%> args merge from entity @s data.locators.$(name)

			IF (debug_mode) {
				execute unless data storage <%temp_storage%> args.uuid run return run tellraw @a <%TELLRAW.LOCATOR_NOT_FOUND()%>
				scoreboard players set #aj.check <%OBJECTIVES.I()%> 0
			}

			block execute_at_transform { with storage <%temp_storage%> args
				IF (debug_mode) {
					# If the function successfully instantiated, the provided command is valid.
					scoreboard players set #aj.check <%OBJECTIVES.I()%> 1
				}

				$execute \
					positioned ^$(px) ^$(py) ^$(pz) \
					rotated ~$(ry) ~$(rx) \
				run $(command)
			}

			IF (debug_mode) {
				execute if score #aj.check <%OBJECTIVES.I()%> matches 0 run tellraw @a <%TELLRAW.LOCATOR_COMMAND_FAILED_TO_EXECUTE()%>
			}
		}
	}

	function at_all_locators {
		#ARGS: {command: string}
		debug assert executed_as_root_entity

		data remove storage <%temp_storage%> args
		$data modify storage <%temp_storage%> args merge value {command:'$(command)'}

		IF (debug_mode) {
			execute if data storage <%temp_storage%> {args:{command:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('command')%>
		}

		execute at @s on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run block zzz/at_all_locators/as_data {
			REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator')) as locator {
				data modify storage <%temp_storage%> args merge from entity @s data.locators.<%locator.storage_name%>
				block execute_at_transform { with storage <%temp_storage%> args
					$execute \
						positioned ^$(px) ^$(py) ^$(pz) \
						rotated ~$(ry) ~$(rx) \
					run $(command)
				}
			}
		}
	}
}

IF (has_cameras) {
	function as_camera {
		#ARGS: {name: string, command: string}
		debug assert executed_as_root_entity

		data remove storage <%temp_storage%> args
		$data modify storage <%temp_storage%> args merge value {name:'$(name)', command:'$(command)', uuid:'+MISSING_UUID+'}

		IF (debug_mode) {
			execute if data storage <%temp_storage%> {args:{name:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('name')%>
			execute if data storage <%temp_storage%> {args:{command:''}} run return run tellraw @a <%TELLRAW.ARGUMENT_CANNOT_BE_EMPTY('command')%>
		}

		execute \
			on passengers \
			if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
		run block zzz/as_camera/as_data { with storage <%temp_storage%> args
			$data modify storage <%temp_storage%> args.uuid set from entity @s data.cameras.$(name).uuid

			IF (debug_mode) {
				scoreboard players set #aj.check <%OBJECTIVES.I()%> 0
			}

			block execute_as_uuid { with storage <%temp_storage%> args
				IF (debug_mode) {
					# If the function successfully instantiated, the provided command is valid.
					scoreboard players set #aj.check <%OBJECTIVES.I()%> 1
				}

				$execute as $(uuid) at @s run return run $(command)

				IF (debug_mode) {
					# If the entity with the provided UUID doesn't exist, the camera wasn't found.
					tellraw @a <%TELLRAW.CAMERA_ENTITY_NOT_FOUND()%>
				}
			}

			IF (debug_mode) {
				execute if score #aj.check <%OBJECTIVES.I()%> matches 0 run tellraw @a <%TELLRAW.CAMERA_COMMAND_FAILED_TO_EXECUTE()%>
			}
		}
	}
}

dir remove {
	function all {
		# Removes all instances of this rig from the world.
		execute as @e[type=minecraft:item_display,tag=<%TAGS.PROJECT_ROOT(export_namespace)%>] run function *<%export_namespace%>/remove/this
	}

	function entities {
		# Removes all entities related to this rig from the world.
		kill @e[tag=<%TAGS.PROJECT_ENTITY(export_namespace)%>]
	}

	function this {
		# Removes the rig this function is executed as.
		debug assert executed_as_root_entity

		<%%
			if (on_remove_function) emit.mcb(on_remove_function)
		%%>

		IF (has_entity_locators) {
			execute on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run block as_data {
				REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator')) as locator {
					IF (locator.config?.on_remove_function) {
						IF (locator.config.use_entity) {
							block as_locator_<%locator.storage_name%> { with entity @s data.locators.<%locator.storage_name%>
								$execute as $(uuid) at @s run block locator_<%locator.storage_name%>_on_remove {
									<%%
										emit.mcb(locator.config.on_remove_function)
									%%>
								}
							}
						} ELSE {
							block at_locator_<%locator.storage_name%> { with entity @s data.locators.<%locator.storage_name%>
								$execute \
									positioned ^$(px) ^$(py) ^$(pz) \
									rotated ~$(ry) ~$(rx) \
								run block locator_<%locator.storage_name%>_on_remove {
									<%%
										emit.mcb(locator.config.on_remove_function)
									%%>
								}
							}
						}
					}
				}
			}
		}

		function ./this/without_on_remove_function
	}

	dir this {
		function without_on_remove_function {
			debug assert executed_as_root_entity

			IF (has_entity_locators || has_cameras) {
				execute on passengers if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] run block as_data {
					REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator' && node.config?.use_entity)) as locator {
						function animated_java:global/remove/entity_stack_by_uuid with entity @s data.locators.<%locator.storage_name%>
					}
					REPEAT (Object.values(rig.nodes).filter(node => node.type === 'camera')) as camera {
						function animated_java:global/remove/entity_stack_by_uuid with entity @s data.cameras.<%camera.storage_name%>
					}
				}
			}

			# Remove the rig using the more expensive & thorough method if the rig_hash doesn't match.
			execute \
				on passengers \
				if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
				unless data entity @s {data:{rig_hash: '<%rig_hash%>'}} \
				on vehicle \
			run function animated_java:global/remove/outdated_rig

			function animated_java:global/remove/entity_stack
		}
	}
}

IF (Object.keys(rig.variants).length > 1) {
	dir variants {
		REPEAT (Object.values(rig.variants)) as variant {
			dir <%variant.name%> {
				function apply {
					debug assert executed_as_root_entity

					<%%
						global.filteredNodes = Object.values(rig.nodes).filter(
							node => (
								node.type === 'bone' &&
								!variant.excluded_nodes.includes(node.uuid) &&
								(	// Variant has a model override or a config override for this bone.
									variant.models[node.uuid] !== undefined ||
									node.configs.variants[variant.uuid] !== undefined
								)
							) || (
								BONE_TYPES.includes(node.type) &&
								!variant.excluded_nodes.includes(node.uuid) &&
								// Variant has a config override for this node.
								node.configs.variants[variant.uuid] !== undefined
							)
						)
					%%>

					REPEAT (global.filteredNodes) as node {
						execute \
							on passengers \
							if entity @s[tag=<%TAGS.PROJECT_NODE_NAMED(export_namespace, node.storage_name)%>] \
							at @s \
						run \
							block zzz/apply_to_node_<%node.storage_name%> {
								IF (node.type === 'bone' && variant.models[node.uuid] !== undefined) {
									# Special case for `animated_java:empty` model.
									IF (variant.models[node.uuid].model === null) {
										data modify entity @s item.components."minecraft:custom_model_data" set value 1
									} ELSE {
										data modify entity @s item.components."minecraft:custom_model_data" set value <%variant.models[node.uuid].custom_model_data%>
									}
								}
								IF (node.configs.variants[variant.uuid]) {
									<%%
										global.config = DisplayEntityConfig.fromJSON(node.configs.variants[variant.uuid])
									%%>
									IF (!global.config.isDefault()) {
										data merge entity @s <%global.config.toNBT(undefined, variant.is_default)%>
									}
									IF (global.config.onApplyFunction) {
										<%%
											emit.mcb(global.config.onApplyFunction)
										%%>
									}
								}
						}
					}
					# Return success to allow this function to be used in function conditions.
					return 1
				}
			}
		}
	}
}

IF (has_locators || has_cameras) {
	dir zzz {
		function reset_floating_entities {
			IF (has_locators) {
				REPEAT (Object.values(rig.nodes).filter(node => node.type === 'locator')) as locator {
					execute \
						at @s \
						on passengers \
						if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
					run block zzz/set_default_pose/as_locator_<%locator.storage_name%> { with entity @s data.locators.<%locator.storage_name%>
						IF (locator.config?.use_entity) {
							$tp $(uuid) \
								^<%roundTo(locator.default_transform.pos[0], 10)%> \
								^<%roundTo(locator.default_transform.pos[1], 10)%> \
								^<%roundTo(locator.default_transform.pos[2], 10)%> \
								~<%roundTo(locator.default_transform.head_rot[1], 10)%> \
								~<%roundTo(locator.default_transform.head_rot[0], 10)%>
						}

						data modify entity @s data.locators.<%locator.storage_name%> merge value { \
							px: <%roundTo(locator.default_transform.pos[0], 10)%>, \
							py: <%roundTo(locator.default_transform.pos[1], 10)%>, \
							pz: <%roundTo(locator.default_transform.pos[2], 10)%>, \
							ry: <%roundTo(locator.default_transform.head_rot[1], 10)%>, \
							rx: <%roundTo(locator.default_transform.head_rot[0], 10)%> \
						}
					}
				}
			}

			IF (has_cameras) {
				REPEAT (Object.values(rig.nodes).filter(node => node.type === 'camera')) as camera {
					execute \
						at @s \
						on passengers \
						if entity @s[tag=<%TAGS.GLOBAL_DATA()%>] \
					run block zzz/set_default_pose/as_camera_<%camera.storage_name%> { with entity @s data.cameras.<%camera.storage_name%>
						$tp $(uuid) \
							^<%roundTo(camera.default_transform.pos[0], 10)%> \
							^<%roundTo(camera.default_transform.pos[1], 10)%> \
							^<%roundTo(camera.default_transform.pos[2], 10)%> \
							~<%roundTo(camera.default_transform.head_rot[1], 10)%> \
							~<%roundTo(camera.default_transform.head_rot[0], 10)%>

						data modify entity @s data.cameras.<%camera.storage_name%> merge value { \
							px: <%roundTo(camera.default_transform.pos[0], 10)%>, \
							py: <%roundTo(camera.default_transform.pos[1], 10)%>, \
							pz: <%roundTo(camera.default_transform.pos[2], 10)%>, \
							ry: <%roundTo(camera.default_transform.head_rot[1], 10)%>, \
							rx: <%roundTo(camera.default_transform.head_rot[0], 10)%> \
						}
					}
				}
			}
		}
	}
}

function apply_default_pose {
	# Changes the pose of the rig to the the default pose with interpolation
	debug assert executed_as_root_entity

	IF (has_locators || has_cameras) {
		function ./zzz/reset_floating_entities
	}

	REPEAT (Object.values(rig.nodes).filter(node => BONE_TYPES.includes(node.type))) as node {
		execute \
			on passengers \
			if entity @s[tag=<%TAGS.PROJECT_NODE_NAMED(export_namespace, node.storage_name)%>] \
		run \
			data merge entity @s { \
				transformation: <%matrixToNbtFloatArray(node.default_transform.matrix).toString()%>, \
				start_interpolation: 0 \
			}
	}
}

function set_default_pose {
	# Changes the pose of the rig to the the default pose without interpolation
	debug assert executed_as_root_entity

	IF (has_locators || has_cameras) {
		function ./zzz/reset_floating_entities
	}

	REPEAT (Object.values(rig.nodes).filter(node => node.type !== 'locator' && node.type !== 'camera')) as node {
		execute \
			on passengers \
			if entity @s[tag=<%TAGS.PROJECT_NODE_NAMED(export_namespace, node.storage_name)%>] \
		run \
			data merge entity @s { \
				transformation: <%matrixToNbtFloatArray(node.default_transform.matrix).toString()%>, \
				start_interpolation: -1 \
			}
	}
}

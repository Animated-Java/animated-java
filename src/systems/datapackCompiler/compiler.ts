import { Parser, SyncIo, Tokenizer } from 'mc-build'
import { AstNode } from 'mc-build/dist/mcl/AstNode'
import { Compiler, VariableMap } from 'mc-build/dist/mcl/Compiler'
import { Token } from 'mc-build/dist/mcl/Tokenizer'
import { getDataPackFormat } from '../../util/minecraftUtil'
import type { MinecraftVersion } from '../global'
import type { ExportedFile } from '../util'

interface CompilerOptions {
	sourceFiles: Record<string, string>
	destPath: string
	variables: Record<string, any>
	version: MinecraftVersion
	exportedFiles: Map<string, ExportedFile>
}

export function compile({
	sourceFiles,
	destPath,
	variables,
	version,
	exportedFiles,
}: CompilerOptions) {
	console.group('Compiling', sourceFiles)
	console.log('Variables:', variables)

	const compiler = new Compiler('src/', {
		libDir: null,
		generatedDirName: 'zzz',
		internalScoreboardName: 'aj.i',
		eqVarScoreboardName: null,
		eqConstScoreboardName: null,
		header: '# This file was generated by Animated Java via MC-Build. It is not recommended to edit this file directly.',
		ioThreadCount: null,
		dontEmitComments: true,
		setup: null,
		formatVersion: getDataPackFormat(version),
	})
	compiler.disableRequire = true
	compiler.templateParsingEnabled = false

	function createSyncIO() {
		const io = new SyncIo()
		io.write = (localPath, content) => {
			const writePath = PathModule.join(destPath, localPath)
			exportedFiles.set(writePath, {
				content,
				includeInAJMeta: true,
			})
		}
		return io
	}
	compiler.io = createSyncIO()

	console.time('MC-Build compiled in')

	const mcbTemplateFiles = Object.entries(sourceFiles).filter(([path]) => path.endsWith('.mcbt'))
	const mcbFiles = Object.entries(sourceFiles).filter(([path]) => path.endsWith('.mcb'))

	for (const [path, mcbFile] of mcbTemplateFiles) {
		let tokens: Token[] = []
		try {
			tokens = Tokenizer.tokenize(mcbFile, path)
		} catch (e) {
			if (e instanceof Error) e.message = `Error tokenizing "${path}":\n\t${e.message}`
			throw e
		}
		let ast: AstNode[] = []
		try {
			ast = Parser.parseMcbtFile(tokens)
		} catch (e) {
			if (e instanceof Error) e.message = `Error tokenizing "${path}":\n\t${e.message}`
			throw e
		}
		compiler.addFile(path, ast)
	}

	for (const [path, mcbFile] of mcbFiles) {
		let tokens: Token[] = []
		try {
			tokens = Tokenizer.tokenize(mcbFile, path)
		} catch (e) {
			if (e instanceof Error) e.message = `Error tokenizing "${path}":\n\t${e.message}`
			throw e
		}
		let ast: AstNode[] = []
		try {
			ast = Parser.parseMcbFile(tokens)
		} catch (e) {
			if (e instanceof Error) e.message = `Error tokenizing "${path}":\n\t${e.message}`
			throw e
		}
		compiler.addFile(path, ast)
	}

	compiler.compile(VariableMap.fromObject(variables))
	console.timeEnd('MC-Build compiled in')
	console.log('Exported files:', exportedFiles.keys())
	console.groupEnd()

	return exportedFiles
}
